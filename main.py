# -*- coding: utf-8 -*-
"""main.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1uABDSMZUNj9xokPxSTjY-Z7vTZhaR7jR
"""

!python --version

# !nvidia-smi

# Using GDrive storage as file-system for experimentation
import os
from google.colab import drive
try:
    drive.mount('/content/gdrive')
    os.chdir('gdrive/My Drive/Glaucoma')
except:
    pass

# Removing Permission if you want to unmount
# https://myaccount.google.com/permissions

os.getcwd()

import warnings
warnings.filterwarnings('ignore')

# Commented out IPython magic to ensure Python compatibility.
import os, shutil, datetime

import numpy as np, pandas as pd

from skimage.io import imread, imshow
from skimage.feature import hog
from skimage.transform import resize

import matplotlib as mlp
import matplotlib.pyplot as plt
import seaborn as sns

# %matplotlib inline

dataset = 'Database-1'
true_path, false_path = 'Glaucoma', 'Healthy'

# orientations, pixels_per_cell, cells_per_block = 8, 64 , 1
orientations, pixels_per_cell, cells_per_block = 8, 8 , 1

MAX_H, MAX_W = 0, 0
for path in  true_path, false_path:
    ls = sorted(((img,imread(os.path.join('.',dataset,path,img)).shape) for img in os.listdir(os.path.join('.',dataset,path))),key=lambda x:x[1][0]*x[1][1], reverse=True)
    print( 'Total Shapes in {0} is {1:d}'.format(path,len(set(x[1] for x in ls))) )
    print(*set(x[1] for x in ls),sep='\n')
    MAX_H, MAX_W = max(MAX_H,max(x[1][0] for x in ls)), max(MAX_W,max(x[1][1] for x in ls))
MAX_H, MAX_W = 32,32
MAX_H, MAX_W = int(pixels_per_cell*np.ceil(MAX_H/pixels_per_cell)), int(pixels_per_cell*np.ceil(MAX_W/pixels_per_cell))
print('Maximum Chosen Height is {0:d} pixels and width is {1:d} pixels'.format(MAX_H, MAX_W))

def show_path(path,M,N):
    fig, ax = plt.subplots(M, N, figsize=(4*M, 5*N), sharex=True, sharey=True)
    fig.suptitle(path, size=36)
    for ix,img_name in enumerate(os.listdir(os.path.join('.',dataset,path))[:M*N]):
        img_mat = imread(os.path.join('.',dataset,path,img_name))
        img_mat = resize(img_mat,(MAX_H, MAX_W))
        ax[ix//M,ix%M].imshow(img_mat, cmap=plt.cm.gray) 
        ax[ix//M,ix%M].set_title(img_name, size=20)

def show_data(M=3, N=3):
    for path in (true_path,false_path):
        show_path(path,M,N)

show_data(M=3, N=3)

def hog_of_path(path, orientations=10, pixels_per_cell=16, cells_per_block=2):
    res = []
    for img_name in os.listdir(os.path.join('.',dataset,path)):
        img_mat = imread(os.path.join('.',dataset,path,img_name))
        img_mat = resize(img_mat,(MAX_H, MAX_W))
        hog_vec = hog(img_mat, orientations=orientations, pixels_per_cell=(pixels_per_cell,pixels_per_cell), cells_per_block=(cells_per_block,cells_per_block))
        res.append( hog_vec )
    return np.array(res)

def get_data(dataset):
    x,y = [], []
    for path, label in zip((true_path,false_path),(1,0)):
        hog_ls = hog_of_path(path, orientations=orientations, pixels_per_cell=pixels_per_cell, cells_per_block=cells_per_block)
        x.extend(hog_ls)
        y.extend([label]*len(hog_ls))
    return np.array(x), np.array(y)

# Commented out IPython magic to ensure Python compatibility.
# %%time
# x,y = get_data(dataset)

x.shape, y.shape, y.sum()

from sklearn.model_selection import StratifiedKFold

from sklearn.naive_bayes  import GaussianNB
from sklearn.neighbors    import KNeighborsClassifier
from sklearn.linear_model import LogisticRegression
from sklearn.svm          import SVC
from sklearn.ensemble     import RandomForestClassifier
  
from sklearn.metrics import accuracy_score

skf = StratifiedKFold(n_splits=5)

# Commented out IPython magic to ensure Python compatibility.
# %%time
# nb = GaussianNB()
# for trn, tst in skf.split(x,y):
#     _ = nb.fit(x[trn],y[trn])
#     print( nb.score(x[tst],y[tst]), accuracy_score(nb.predict(x[tst]),y[tst]) )

# Commented out IPython magic to ensure Python compatibility.
# %%time
# knn = KNeighborsClassifier(n_neighbors=32)
# for trn, tst in skf.split(x,y):
#     _ = knn.fit(x[trn],y[trn])
#     print( knn.score(x[tst],y[tst]), accuracy_score(knn.predict(x[tst]),y[tst]) )

# Commented out IPython magic to ensure Python compatibility.
# %%time
# knn = KNeighborsClassifier(n_neighbors=16)
# for trn, tst in skf.split(x,y):
#     _ = knn.fit(x[trn],y[trn])
#     print( knn.score(x[tst],y[tst]), accuracy_score(knn.predict(x[tst]),y[tst]) )

# Commented out IPython magic to ensure Python compatibility.
# %%time
# lg = LogisticRegression()
# for trn, tst in skf.split(x,y):
#     _ = lg.fit(x[trn],y[trn])
#     print( lg.score(x[tst],y[tst]), accuracy_score(lg.predict(x[tst]),y[tst]) )

lg.predict_proba(x[tst])

y[tst]

# Commented out IPython magic to ensure Python compatibility.
# %%time
# svc = SVC(kernel='poly',degree=1)
# for trn, tst in skf.split(x,y):
#     _ = svc.fit(x[trn],2*y[trn]-1)
#     print( svc.score(x[tst],2*y[tst]-1), accuracy_score(svc.predict(x[tst]),2*y[tst]-1) )

# Commented out IPython magic to ensure Python compatibility.
# %%time
# svc = SVC(kernel='rbf')
# for trn, tst in skf.split(x,y):
#     _ = svc.fit(x[trn],2*y[trn]-1)
#     print( svc.score(x[tst],2*y[tst]-1), accuracy_score(svc.predict(x[tst]),2*y[tst]-1) )

# Commented out IPython magic to ensure Python compatibility.
# %%time
# rf = RandomForestClassifier(n_estimators=5, max_features=40, max_depth=10)
# for trn, tst in skf.split(x,y):
#     _ = rf.fit(x[trn],y[trn])
#     print( rf.score(x[tst],y[tst]), accuracy_score(rf.predict(x[tst]),y[tst]) )

sorted(rf.feature_importances_,reverse=True)[:10]

# Commented out IPython magic to ensure Python compatibility.
# %%time
# rf = RandomForestClassifier(n_estimators=100, max_features=40, max_depth=10)
# for trn, tst in skf.split(x,y):
#     _ = rf.fit(x[trn],y[trn])
#     print( rf.score(x[tst],y[tst]), accuracy_score(rf.predict(x[tst]),y[tst]) )

sorted(rf.feature_importances_,reverse=True)[:10]

